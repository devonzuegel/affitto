// Generated by CoffeeScript 1.10.0
(function() {
  var Maps, MyModel, Shapes, log, model, u,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  u = ABM.Util;

  Shapes = ABM.Shapes;

  Maps = ABM.ColorMaps;

  log = function(arg) {
    return console.log(arg);
  };

  MyModel = (function(superClass) {
    extend(MyModel, superClass);

    function MyModel() {
      return MyModel.__super__.constructor.apply(this, arguments);
    }

    MyModel.prototype.gaussian_approx = function(_min, _max) {
      var curve, diff, middle;
      if (_min == null) {
        _min = 0;
      }
      if (_max == null) {
        _max = 1;
      }
      curve = ((Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random()) - 4) / 4;
      diff = _max - _min;
      middle = _max - diff / 2.0;
      return middle + diff * curve;
    };

    MyModel.prototype.setup = function() {
      var a, i, j, k, l, len, len1, nvals, p, ref, ref1, ref2, v, vals;
      vals = 0;
      nvals = 1000;
      for (i = j = 0, ref = nvals; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        v = this.gaussian_approx(0, 100);
        vals += v;
      }
      log(vals / nvals);
      return;
      this.population = 3;
      this.size = 0.9;
      this.speed = 0.3;
      this.wiggle = u.degToRad(30);
      this.turtles.setUseSprites();
      this.turtles.setDefault('size', this.size);
      this.anim.setRate(30, false);
      ref1 = this.patches;
      for (k = 0, len = ref1.length; k < len; k++) {
        p = ref1[k];
        p.color = Maps.randomGray(0, 100);
        p.price = 11111111;
      }
      ref2 = this.turtles.create(this.population);
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        a = ref2[l];
        a.shape = 'person';
      }
      return log(this.patches.patchXY(0, 0));
    };

    MyModel.prototype.step = function() {
      var a, j, k, len, len1, p, ref, ref1;
      ref = this.turtles;
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        this.updateTurtles(a);
      }
      if (this.anim.ticks % 100 === 0) {
        ref1 = this.patches;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          p = ref1[k];
          this.updatePrices(p);
        }
        this.reportInfo();
        this.refreshPatches = true;
        if (this.anim.ticks === 300) {
          return this.setSpotlight(this.turtles.oneOf());
        }
      } else {
        return this.refreshPatches = false;
      }
    };

    MyModel.prototype.updateTurtles = function(t) {
      t.rotate(u.randomCentered(this.wiggle));
      return t.forward(this.speed);
    };

    MyModel.prototype.updatePrices = function(p) {};

    MyModel.prototype.reportInfo = function() {
      var avgHeading, headings;
      headings = this.turtles.getProp("heading");
      avgHeading = (headings.reduce(function(a, b) {
        return a + b;
      })) / this.turtles.length;
      return log("average heading of turtles: " + (avgHeading.toFixed(2)) + " radians, " + (u.radToDeg(avgHeading).toFixed(2)) + " degrees");
    };

    return MyModel;

  })(ABM.Model);

  model = new MyModel({
    div: "layers",
    size: 20,
    minX: -16,
    maxX: 16,
    minY: -16,
    maxY: 16,
    isTorus: true,
    hasNeighbors: false
  }).debug().start();

}).call(this);
